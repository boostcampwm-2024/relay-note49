# **퀘스트 1. 실패 및 에러 이유 문서화**

> ✔️ **수행기준**
> 
> - 키워드라도 표시해서 바로 실패 및 에러 이유를 적어둔다.
> - 하루에 하나라도 실패 및 에러 이유를 적어둔다.

## 7/29(월) ✅

### “작업자 한 명당 2개의 물품까지 동시에 분류할 수 있다.”

분류하는 중간에 새로운 물품이 들어오는데, 어떻게 동시에 처리하지?

예를 들어서, 처음에 1개의 소형 물품이 할당돼서 이를 처리하고 있는데

1초가 지났을 때 새로운 물품이 할당된다면, 이를 어떻게 동시에 실행하지?

결국 “비동기”로 처리해서, 1초가 지난 시점에 새로운 물품의 분류를 시작하라는 말로 해석.

나는 지금 작업자에게 할당된 물품을 배열로 관리하고있는데,

어떤 물품을 분류하는 동안 새로운 물품이 들어오면 이 배열에 변동이 생기는 상황.

그럼 배열에 변동이 생기는 걸 감지해야하는가…?

```jsx
export default class Worker extends EventEmitter {
  constructor(id) {
    super();
    this.workerId = id;
    this.assignedItems = [];
  }

  assignItem(item) {
    this.assignedItems.push(item);
    this.arrangeItem();
  }

  arrangeItem() {
    this.assignedItems.forEach((item) => {
      setTimeout(() => {
        this.emit("분류 완료", item);
      }, item.arrangingTime);
    });
  }
```

이렇게 forEach로 접근하면 똑같은 물품을 또 분류하게 된다.

### 해결방법

```jsx
  addItem(item) {
    this.centerQueue.enqueue(item);
    this.process();
  }

  process() {
    // 주기적으로 worker에게 할당을 시도
    this.assignItemToWorker();
    setInterval(() => {
      this.assignItemToWorker();
    }, 1000);
  }

  assignItemToWorker() {
    this.workers.forEach((worker) => {
      // 작업자 한 명당 최대 2개의 아이템을 처리할 수 있다.
      if (!this.centerQueue.isEmpty() && worker.arrangingItems.length < 2) {
        const item = this.centerQueue.dequeue();
        worker.arrangeItem(item);
      }
    });
  }
```

새로운 물품을 Center에 넘겨줄때 addItem 메소드를 사용하게 되고, addItem이 됐다면 assignItemToWorker 메소드에서 여유 일손이 있는 작업자에게(2개를 처리하고 있지 않은 작업자) 물품을 할당하게 된다. 여기서 setInterval로 작업자의 여유 일손을 지속적으로 확인해줌으로써 문제를 해결했다.

## 7/30(화) ✅

## 정적 의존성을 동적 의존성(의존성 주입)으로 바꾸기

의존성 주입, 즉 SystemHandler에서 직접 만들고 있는 속성들을 내부에서 만드는게 아니라 외부에서 주입하도록 하는 것이 더 나은 선택일까?

### 의존성 주입의 장점

- 코드의 재사용성, 유연성이 높아진다. 객체의 역할을 더 세분화하기 때문이다.
- 객체간 결합도를 낮출 수 있다.
- 유지보수와 확장이 더 용이해진다.

### 의존성 주입의 단점

- 책임을 분리하기 때문에 클래스 수가 늘어나서 복잡성이 증가한다.
- 주입된 객체에 대해 코드 추적이 어렵다.

따라서 나는 정적 의존성을 동적 의존성으로 바꾸는 것이 조금이라도 의존성을 느슨하게 만드는 방법이라고 판단했다.

아 그런데 모듈을 분리할 수록 어째… 코드가 더 복잡해지고 가독성도 안좋아진다. 의존성이 엮이는 객체 수만 더 늘리는 느낌이다.

```jsx
export default class Pos {
  constructor(
    centerCount,
    workerCount,
    deliveryDriverCount,
    receptionQueue,
    items,
    deliveryDrivers,
    workers,
    centers,
    manager
  ) {
    this.centerCount = centerCount;
    this.workerCount = workerCount;
    this.deliveryDriverCount = deliveryDriverCount;
    this.receptionQueue = receptionQueue;
    this.items = items;
    this.deliveryDrivers = deliveryDrivers;
    this.workers = workers;
    this.centers = centers;
    this.manager = manager;
  }

```

**애초에 Pos 내부에서 너무 많은 값을 필요로 한다는 것이 문제라는 생각이 들었다.**

**그래서 다른 곳으로 옮기거나 제거할 수 있는 값은 제거하는 방향으로 개선을 해보았다.**

- pos에서 필요로 하는 데이터를 초기화하는 Initializer 모듈 분리
- 출력 부를 담당하는 Dashboard 모듈 분리
- Initializer에서 이벤트 등록까지 전부 처리
- receptionQueue의 생성을 Manager로 이관
- centerCount, workerCount, deliveryDriverCount값을 넘기지 않고 상수를 이용해서 처리
- pos에서 꼭 필요하지 않은 값들 정리
    - centers안에 workers 정보가 있으므로 workers정보를 따로 넘길 필요 없음
    - workers 안에 deliveryDrivers 정보가 있으므로 deliveryDrivers 정보를 따로 넘길 필요 없음

결과적으로, Pos의 constructor가 이렇게 깔끔해졌다.

```jsx
export default class Pos {
  constructor(centers, manager) {
    this.items = [];
    this.centers = centers;
    this.manager = manager;
    this.dashboard = new Dashboard(this.centers, this.items);
  }
```

## 7/31(수) ✅

## add에서 변경파일만을 감지하지 못하는 문제상황

- 커밋1 : 초기상태
- 커밋2 : newTest.js 수정
- 커밋3 : newTest2.js 생성, newTest.js 수정

```bash
mit log .
커밋ID:  ca41cacce71ce78c28eb82c307391433846747bd29fe57b3a85286c0b4485eb1
.DS_Store
.gitignore
.vsls.json
README.md
add.js
commit.js
init.js
jest.config.js
log.js
logTest.txt
main.js
newTest.txt
newTest2.txt
package-lock.json
package.json
restore.js
status.js
test.js
unzipTest.js
zipTest.txt
--------------------------------------------------------------------------
커밋ID:  83a55ef45d9356f9a870adae948770ac75e510fcd30bde34f61569fcc080f41a
newTest.txt
--------------------------------------------------------------------------
커밋ID:  f5195f36ee6f9f7d791b6c025bc0a591a14d5ee219554874163f087c7b99ce05
.DS_Store
.gitignore
.vsls.json
README.md
add.js
commit.js
init.js
jest.config.js
log.js
logTest.txt
main.js
newTest.txt
package-lock.json
package.json
restore.js
status.js
test.js
unzipTest.js
zipTest.txt
--------------------------------------------------------------------------
```

그런데 git log를 찍어보면 (위에서부터 순서대로 커밋3, 2, 1)

정상적인 작동이라면 커밋3에서 newTest.js랑 newTest2.js만 찍혀야하는데 모든파일이 찍히고있다.

왜냐면 커밋을 할 때 그때 시점에서의 tree랑 현재 존재하는 파일들을 비교를해서 tree에 없는 내용이라면 변경된 것으로 인식하고 commit에 올리는데,

커밋3을 하는 시점의 tree에는 newTest.js밖에 들어있지가 않다. 커밋2에서 newTest.js밖에 변경이 안됐기 때문이다.

그래서 커밋3을 할 때 모든 파일이 tree 오브젝트와 commit 오브젝트에 올라가는 것이다.

```jsx
const isSame = lastTreeContentsBlobHashes.includes(fileHash)
if(!isSame) toIndexFileList.push(fileName);
```

현재 add에서 로직이 이렇다. 마지막 트리가 가지고있지 않은 파일을 전부 add하기 때문에 이런 문제가 발생하는 것이다. 마지막 트리가 가지고 있는건 오로지 ‘변경된 파일들’에 대한 정보이기 때문에, 변경되지 않고 가만히 있는 파일들은 트리에 없다. 그래서 변경되지 않고 가만히 있는 파일들까지 새로 생긴 파일이라고 여겨져서 커밋에 반영되는 것이다.

그래서 이렇게 해보기로 했다.

```jsx
const isExist = fs.existsSync(path.join(objectsPath,blobDir,blobObj));
if(!isExist)toIndexFileList.push(fileName);
```

기존 : 마지막 트리가 가지고있지 않은 파일을 전부 add

변경 : 현재 존재하지 않는 파일을 전부 add

→ 이렇게 하면 변경되지 않고 가만히 있는 파일들은 add되지 않는다.

## 8/01(목) ✅

![Untitled](https://github.com/user-attachments/assets/841601b2-63a7-430e-9b6b-df007f4508cf)


- ES moudle 환경에서 파일을 import할 때 .js 확장자를 붙이지 않으면 인식을 못함.
- 알아보니 원래 ES module이 그렇다고 함.
